<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ€æˆ®å°–å¡” - ç½‘é¡µç‰ˆ</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        // æ·»åŠ å…¨å±€é”™è¯¯å¤„ç†
        window.onerror = function(message, source, lineno, colno, error) {
            console.error('å…¨å±€é”™è¯¯:', message, source, lineno, colno, error);
            alert('å‘ç”Ÿé”™è¯¯: ' + message);
        };
    </script>
</head>
<body>
    <div class="container">
        <div id="player-status" class="hidden">
            <div class="status-left">
                <div id="player-name" class="status-item">æ— åè‹±é›„</div>
                <div id="player-hp" class="status-item">â¤ï¸ 0/0</div>
                <div id="player-energy" class="status-item">âš¡ï¸ 0/0</div>
                <div id="player-gold" class="status-item">ğŸ’° 0</div>
                <div id="player-block" class="status-item"></div>
            </div>
            <div class="pile-info">
                <div id="draw-pile">æŠ½ç‰Œå †: 0</div>
                <div id="discard-pile">å¼ƒç‰Œå †: 0</div>
            </div>
        </div>
        <div id="game-container">
            <div id="game-screen"></div>
            <div id="game-controls">
            </div>
        </div>
    </div>

    <!-- JSæ¨¡æ¿ -->
    <template id="main-menu-template">
        <div id="main-menu" class="screen">
            <h1>æ€æˆ®å°–å¡”</h1>
            <div class="menu-options">
                <button id="new-game-btn">æ–°æ¸¸æˆ</button>
                <button id="load-game-btn">åŠ è½½æ¸¸æˆ</button>
            </div>
        </div>
    </template>

    <template id="load-game-template">
        <div id="load-game" class="screen">
            <h2>åŠ è½½æ¸¸æˆ</h2>
            <div class="load-game-form">
                <input type="text" id="save-name-input" placeholder="è¾“å…¥å­˜æ¡£å">
                <button id="load-save-btn">åŠ è½½</button>
                <button id="back-to-menu-btn">è¿”å›</button>
            </div>
        </div>
    </template>

    <template id="deck-view-template">
        <div id="deck-view" class="screen">
            <h2>ä½ çš„ç‰Œç»„</h2>
            <div id="deck-cards"></div>
            <button id="close-deck-btn">å…³é—­</button>
        </div>
    </template>

    <template id="rewards-screen-template">
        <div id="rewards-screen" class="screen">
            <h2>æˆ˜æ–—å¥–åŠ±</h2>
            <div id="rewards-container">
                <div id="card-rewards" class="rewards-section"></div>
                <div id="gold-reward" class="rewards-section"></div>
                <div id="relic-reward" class="rewards-section"></div>
            </div>
            <button id="skip-rewards-btn">è·³è¿‡</button>
        </div>
    </template>

    <template id="shop-screen-template">
        <div id="shop-screen" class="screen">
            <h2>å•†åº—</h2>
            <div id="shop-container">
                <div id="shop-cards" class="shop-section">
                    <h3>å¡ç‰Œ</h3>
                    <div class="shop-items"></div>
                </div>
                <div id="shop-relics" class="shop-section">
                    <h3>é—ç‰©</h3>
                    <div class="shop-items"></div>
                </div>
                <div id="shop-potions" class="shop-section">
                    <h3>è¯æ°´</h3>
                    <div class="shop-items"></div>
                </div>
            </div>
            <button id="leave-shop-btn">ç¦»å¼€å•†åº—</button>
        </div>
    </template>

    <template id="rest-site-template">
        <div id="rest-site" class="screen">
            <h2>ä¼‘æ¯ç‚¹</h2>
            <div class="rest-options">
                <div class="rest-option" data-option="rest">
                    <h3>ä¼‘æ¯</h3>
                    <p>æ¢å¤30%æœ€å¤§ç”Ÿå‘½å€¼</p>
                </div>
                <div class="rest-option" data-option="upgrade">
                    <h3>å‡çº§å¡ç‰Œ</h3>
                    <p>å‡çº§ä½ çš„ä¸€å¼ å¡ç‰Œ</p>
                </div>
            </div>
        </div>
    </template>

    <template id="upgrade-card-template">
        <div id="upgrade-card" class="screen">
            <h2>é€‰æ‹©è¦å‡çº§çš„å¡ç‰Œ</h2>
            <div id="upgradeable-cards"></div>
            <button id="back-to-rest-btn">è¿”å›</button>
        </div>
    </template>

    <template id="event-screen-template">
        <div id="event-screen" class="screen">
            <h2 id="event-title"></h2>
            <p id="event-description"></p>
            <div id="event-choices"></div>
        </div>
    </template>

    <template id="character-select-template">
        <div id="character-select" class="screen">
            <h2>é€‰æ‹©ä½ çš„è§’è‰²</h2>
            <div class="character-options">
                <div class="character-card" data-char-id="1">
                    <h3>é“ç”²æˆ˜å£«</h3>
                    <p>å¹³è¡¡å‹è§’è‰²ï¼Œæ“…é•¿é˜²å¾¡å’ŒåŠ›é‡æå‡ã€‚</p>
                </div>
                <div class="character-card" data-char-id="2">
                    <h3>é™é»˜çŒæ‰‹</h3>
                    <p>æ“…é•¿ä¸­æ¯’å’Œå¿«é€Ÿå‡ºç‰Œã€‚</p>
                </div>
                <div class="character-card" data-char-id="3">
                    <h3>æ•…éšœæœºå™¨äºº</h3>
                    <p>æ“…é•¿èƒ½é‡æ“æ§å’Œå……èƒ½çƒã€‚</p>
                </div>
            </div>
            <input type="text" id="player-name-input" placeholder="è¾“å…¥ä½ çš„åå­—">
            <button id="start-game-btn">å¼€å§‹æ¸¸æˆ</button>
        </div>
    </template>
    
    <template id="map-screen-template">
        <div id="map-screen" class="screen">
            <h2>åœ°å›¾ (æ¥¼å±‚: <span id="floor-number"></span>)</h2>
            <div id="map-nodes"></div>
            <div class="map-controls">
                <button id="view-deck-btn">æŸ¥çœ‹ç‰Œç»„</button>
            </div>
        </div>
    </template>

    <template id="combat-screen-template">
        <div id="combat-screen" class="screen">
            <div id="enemies-area"></div>
            <div id="player-area">
                <div id="player-character"></div>
                <div id="hand-area"></div>
            </div>
            <div id="combat-controls">
                <button id="end-turn-btn">ç»“æŸå›åˆ</button>
            </div>
        </div>
    </template>

    <script>
        // åŠ¨æ€è·å–å½“å‰é¡µé¢çš„ä¸»æœºåå’Œç«¯å£
        const currentUrl = window.location.origin;
        console.log('Current URL:', currentUrl);
        
        // æ·»åŠ Socket.IOè¿æ¥çŠ¶æ€ç›‘å¬
        let socket;
        try {
            socket = io(currentUrl, {
                transports: ['websocket', 'polling'],
                reconnection: true,
                reconnectionAttempts: 5,
                reconnectionDelay: 1000,
                timeout: 20000,
                autoConnect: false // æ‰‹åŠ¨è¿æ¥
            });
            
            // è¿æ¥äº‹ä»¶ç›‘å¬
            socket.on('connect', () => {
                console.log('Socket.IOè¿æ¥æˆåŠŸ! ID:', socket.id);
                document.getElementById('game-controls').innerHTML += '<span style="color: green;">å·²è¿æ¥</span>';
            });
            
            socket.on('connect_error', (error) => {
                console.error('Socket.IOè¿æ¥é”™è¯¯:', error);
                document.getElementById('game-controls').innerHTML += '<span style="color: red;">è¿æ¥é”™è¯¯: ' + error.message + '</span>';
            });
            
            socket.on('disconnect', (reason) => {
                console.log('Socket.IOæ–­å¼€è¿æ¥:', reason);
                document.getElementById('game-controls').innerHTML += '<span style="color: orange;">å·²æ–­å¼€: ' + reason + '</span>';
            });
            
            // æ‰‹åŠ¨è¿æ¥
            console.log('æ­£åœ¨è¿æ¥Socket.IO...');
            socket.connect();
        } catch (error) {
            console.error('Socket.IOåˆå§‹åŒ–é”™è¯¯:', error);
            alert('Socket.IOåˆå§‹åŒ–é”™è¯¯: ' + error.message);
        }
        
        const gameScreen = document.getElementById('game-screen');
        let gameState = null;
        let selectedTarget = null;

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            const playerStatus = document.getElementById('player-status');
            
            // åˆå§‹åŒ–æ¸¸æˆç•Œé¢
            renderMainMenu();
            
            // WebSocketäº‹ä»¶å¤„ç†
            socket.on('connected', function(data) {
                console.log('Connected to server with SID:', data.sid);
            });

            socket.on('update_state', function(state) {
                if (!state) return;
                
                gameState = state;
                console.log('Game state updated:', state);
                
                // æ ¹æ®å½“å‰å±å¹•æ¸²æŸ“ç›¸åº”ç•Œé¢
                switch(state.screen) {
                    case 'map':
                        renderMap(state);
                        break;
                    case 'combat':
                        renderCombat(state);
                        break;
                    case 'rewards':
                        renderRewards(state);
                        break;
                    case 'shop':
                        renderShop(state);
                        break;
                    case 'rest':
                        renderRestSite(state);
                        break;
                    case 'event':
                        renderEvent(state);
                        break;
                    default:
                        renderMap(state);
                }
            });

            socket.on('game_error', function(data) {
                console.error('Game Error:', data.error);
                alert(`å‘ç”Ÿé”™è¯¯: ${data.error}`);
            });
        });
        
        // èŠ‚ç‚¹ç±»å‹å¯¹åº”çš„Emoji
        const NODE_EMOJIS = {
            'æˆ˜æ–—': 'âš”ï¸',
            'ç²¾è‹±': 'ğŸ‘¹',
            'BOSS': 'ğŸ‘‘',
            'å®ç®±': 'ğŸ’°',
            'å•†åº—': 'ğŸª',
            'ä¼‘æ¯': 'ğŸ”¥',
            'äº‹ä»¶': 'â“'
        };

        // --- æ¸²æŸ“å‡½æ•° ---
        
        function render(state) {
            gameState = state;
            if (!state) {
                renderMainMenu();
                playerStatus.classList.add('hidden');
                return;
            }
            
            updatePlayerStatus(state.player);
            playerStatus.classList.remove('hidden');

            switch (state.screen) {
                case 'map':
                    renderMap(state);
                    break;
                case 'combat':
                    renderCombat(state);
                    break;
                case 'rewards':
                    renderRewards(state);
                    break;
                case 'shop':
                    renderShop(state);
                    break;
                case 'rest':
                    renderRestSite(state);
                    break;
                case 'event':
                    renderEvent(state);
                    break;
                default:
                    renderMainMenu();
            }
        }
        
        function renderMainMenu() {
            const template = document.getElementById('main-menu-template').content.cloneNode(true);
            gameScreen.innerHTML = '';
            gameScreen.appendChild(template);
            
            document.getElementById('new-game-btn').addEventListener('click', () => {
                renderCharacterSelect();
            });
            
            document.getElementById('load-game-btn').addEventListener('click', () => {
                renderLoadGame();
            });
        }

        function renderLoadGame() {
            const template = document.getElementById('load-game-template').content.cloneNode(true);
            gameScreen.innerHTML = '';
            gameScreen.appendChild(template);
            
            document.getElementById('load-save-btn').addEventListener('click', () => {
                const saveName = document.getElementById('save-name-input').value;
                if (!saveName) {
                    alert('è¯·è¾“å…¥å­˜æ¡£å');
                    return;
                }
                socket.emit('load_game', { saveName });
            });
            
            document.getElementById('back-to-menu-btn').addEventListener('click', () => {
                renderMainMenu();
            });
        }

        function renderCharacterSelect() {
            const template = document.getElementById('character-select-template').content.cloneNode(true);
            gameScreen.innerHTML = '';
            gameScreen.appendChild(template);

            document.querySelectorAll('.character-card').forEach(card => {
                card.addEventListener('click', (e) => {
                    document.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected'));
                    e.currentTarget.classList.add('selected');
                });
            });
            
            document.getElementById('start-game-btn').addEventListener('click', () => {
                const selectedChar = document.querySelector('.character-card.selected');
                if (!selectedChar) {
                    alert('è¯·é€‰æ‹©ä¸€ä¸ªè§’è‰²');
                    return;
                }
                const characterId = selectedChar.dataset.charId;
                const playerName = document.getElementById('player-name-input').value || 'æ— åè‹±é›„';
                socket.emit('new_game', { characterId, playerName });
            });
        }

        function updatePlayerStatus(player) {
            document.getElementById('player-name').textContent = player.name;
            document.getElementById('player-hp').textContent = `â¤ï¸ ${player.health}/${player.maxHealth}`;
            document.getElementById('player-energy').textContent = `âš¡ï¸ ${player.energy}/${player.maxEnergy}`;
            document.getElementById('player-gold').textContent = `ğŸ’° ${player.gold}`;
            document.getElementById('player-block').textContent = player.block > 0 ? `ğŸ›¡ï¸ ${player.block}` : '';

            const drawPile = document.getElementById('draw-pile');
            const discardPile = document.getElementById('discard-pile');
            drawPile.textContent = `æŠ½ç‰Œå †: ${player.drawPile.length}`;
            discardPile.textContent = `å¼ƒç‰Œå †: ${player.discardPile.length}`;
        }

        function renderMap(state) {
            const template = document.getElementById('map-screen-template').content.cloneNode(true);
            gameScreen.innerHTML = '';
            gameScreen.appendChild(template);
            
            document.getElementById('floor-number').textContent = state.floor;
            const mapNodesContainer = document.getElementById('map-nodes');
            mapNodesContainer.innerHTML = '';

            state.map.nodes.forEach((row, rowIndex) => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'map-row';
                row.forEach((node, colIndex) => {
                    const nodeDiv = document.createElement('div');
                    nodeDiv.className = 'map-node';
                    nodeDiv.textContent = NODE_EMOJIS[node.type] || node.type;
                    nodeDiv.dataset.row = rowIndex;
                    nodeDiv.dataset.col = colIndex;
                    nodeDiv.title = node.type; // é¼ æ ‡æ‚¬åœæç¤º
                    
                    if (node.visited) {
                        nodeDiv.classList.add('visited');
                    }
                    
                    // é«˜äº®å¯é€‰è·¯å¾„
                    if (rowIndex === state.floor + 1 && isPathAvailable(state.map.currentNode, node, rowIndex)) {
                        nodeDiv.classList.add('available');
                        
                        // ä¸ºå¯é€‰è·¯å¾„æ·»åŠ ç‚¹å‡»äº‹ä»¶
                        nodeDiv.addEventListener('click', () => {
                            socket.emit('player_action', {
                                action: 'choose_path',
                                payload: { row: rowIndex, col: colIndex }
                            });
                        });
                    }
                    
                    rowDiv.appendChild(nodeDiv);
                });
                mapNodesContainer.appendChild(rowDiv);
            });
            
            // æ·»åŠ æŸ¥çœ‹ç‰Œç»„æŒ‰é’®äº‹ä»¶
            document.getElementById('view-deck-btn').addEventListener('click', () => {
                renderDeckView(state.player.deck);
            });
        }
        
        // åˆ¤æ–­è·¯å¾„æ˜¯å¦å¯é€‰
        function isPathAvailable(currentNode, targetNode, targetRow) {
            // åªèƒ½å‘ä¸Šä¸€å±‚ç§»åŠ¨
            if (targetRow !== gameState.floor + 1) {
                return false;
            }
            
            // ç®€åŒ–çš„è·¯å¾„åˆ¤æ–­ï¼šå…è®¸45åº¦è§’ç§»åŠ¨
            const currentX = currentNode.x;
            const currentY = currentNode.y;
            const targetX = targetNode.x;
            const targetY = targetNode.y;
            
            // å‚ç›´è·ç¦»å¿…é¡»ä¸º1
            const verticalDist = targetY - currentY;
            if (verticalDist !== 1) {
                return false;
            }
            
            // æ°´å¹³è·ç¦»ä¸èƒ½å¤ªè¿œ
            const horizontalDist = Math.abs(targetX - currentX);
            return horizontalDist <= 1;
        }
        
        function renderDeckView(deck) {
            const template = document.getElementById('deck-view-template').content.cloneNode(true);
            gameScreen.innerHTML = '';
            gameScreen.appendChild(template);
            
            const deckCards = document.getElementById('deck-cards');
            
            // æŒ‰ç±»å‹åˆ†ç»„å¡ç‰Œ
            const cardsByType = {};
            deck.forEach(card => {
                if (!cardsByType[card.card_type]) {
                    cardsByType[card.card_type] = [];
                }
                cardsByType[card.card_type].push(card);
            });
            
            // ä¸ºæ¯ç§ç±»å‹åˆ›å»ºä¸€ä¸ªåŒºåŸŸ
            for (const [type, cards] of Object.entries(cardsByType)) {
                const typeDiv = document.createElement('div');
                typeDiv.className = 'card-type-group';
                typeDiv.innerHTML = `<h3>${type} (${cards.length})</h3>`;
                
                const cardsContainer = document.createElement('div');
                cardsContainer.className = 'cards-container';
                
                cards.forEach(card => {
                    const cardDiv = document.createElement('div');
                    cardDiv.className = 'card small-card';
                    if (card.upgraded) {
                        cardDiv.classList.add('upgraded');
                    }
                    cardDiv.innerHTML = `
                        <h5>${card.name} [${card.cost}]</h5>
                        <p>${card.description}</p>
                    `;
                    cardsContainer.appendChild(cardDiv);
                });
                
                typeDiv.appendChild(cardsContainer);
                deckCards.appendChild(typeDiv);
            }
            
            document.getElementById('close-deck-btn').addEventListener('click', () => {
                // æ ¹æ®å½“å‰å±å¹•çŠ¶æ€é‡æ–°æ¸²æŸ“
                if (gameState && gameState.screen) {
                    switch(gameState.screen) {
                        case 'map':
                            renderMap(gameState);
                            break;
                        case 'combat':
                            renderCombat(gameState);
                            break;
                        case 'rewards':
                            renderRewards(gameState);
                            break;
                        case 'shop':
                            renderShop(gameState);
                            break;
                        case 'rest':
                            renderRestSite(gameState);
                            break;
                        case 'event':
                            renderEvent(gameState);
                            break;
                        default:
                            renderMap(gameState);
                    }
                } else {
                    renderMainMenu();
                }
            });
        }

        function renderCombat(state) {
            const template = document.getElementById('combat-screen-template').content.cloneNode(true);
            gameScreen.innerHTML = '';
            gameScreen.appendChild(template);

            // æ¸²æŸ“æ•Œäºº
            const enemiesArea = document.getElementById('enemies-area');
            enemiesArea.innerHTML = '';
            state.currentEnemies.forEach((enemy, index) => {
                const enemyDiv = document.createElement('div');
                enemyDiv.className = 'enemy';
                enemyDiv.innerHTML = `
                    <h4>${enemy.name}</h4>
                    <p>â¤ï¸ ${enemy.health}/${enemy.maxHealth}</p>
                    <p>æ„å›¾: ${enemy.intent || 'æ— '} ${enemy.intentValue ? enemy.intentValue : ''}</p>
                    ${enemy.block > 0 ? `<p>ğŸ›¡ï¸ ${enemy.block}</p>` : ''}
                    ${enemy.strength > 0 ? `<p>ğŸ’ª ${enemy.strength}</p>` : ''}
                    ${enemy.poison > 0 ? `<p>â˜ ï¸ ${enemy.poison}</p>` : ''}
                `;
                enemyDiv.dataset.index = index;
                // ç‚¹å‡»é€‰æ‹©ä¸ºç›®æ ‡
                enemyDiv.addEventListener('click', (e) => {
                    if (selectedTarget === e.currentTarget) {
                        selectedTarget.classList.remove('selected-target');
                        selectedTarget = null;
                    } else {
                        document.querySelectorAll('.enemy').forEach(en => en.classList.remove('selected-target'));
                        selectedTarget = e.currentTarget;
                        selectedTarget.classList.add('selected-target');
                    }
                });
                enemiesArea.appendChild(enemyDiv);
            });

            // æ¸²æŸ“æ‰‹ç‰Œ
            const handArea = document.getElementById('hand-area');
            handArea.innerHTML = '';
            state.player.hand.forEach((card, index) => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card';
                if (card.upgraded) {
                    cardDiv.classList.add('upgraded');
                }
                cardDiv.innerHTML = `
                    <h5>${card.name} [${card.cost}]</h5>
                    <p>${card.description}</p>
                `;
                cardDiv.dataset.index = index;

                // ç‚¹å‡»ä½¿ç”¨å¡ç‰Œ
                cardDiv.addEventListener('click', () => {
                    let targetIndex = null;
                    if (card.card_type === 'æ”»å‡»') {
                        if (state.currentEnemies.length > 1) {
                            if (!selectedTarget) {
                                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªç›®æ ‡æ•Œäººï¼');
                                return;
                            }
                            targetIndex = parseInt(selectedTarget.dataset.index);
                        } else {
                            targetIndex = 0;
                        }
                    }
                    socket.emit('player_action', {
                        action: 'play_card',
                        payload: { card_index: index, target_index: targetIndex }
                    });
                    if (selectedTarget) {
                        selectedTarget.classList.remove('selected-target');
                        selectedTarget = null;
                    }
                });

                handArea.appendChild(cardDiv);
            });

            // ç»“æŸå›åˆæŒ‰é’®
            document.getElementById('end-turn-btn').addEventListener('click', () => {
                socket.emit('player_action', { action: 'end_turn' });
            });
        }
        
        function renderRewards(state) {
            const template = document.getElementById('rewards-screen-template').content.cloneNode(true);
            gameScreen.innerHTML = '';
            gameScreen.appendChild(template);
            
            const rewards = state.rewards;
            
            // æ¸²æŸ“å¡ç‰Œå¥–åŠ±
            if (rewards.cards && rewards.cards.length > 0) {
                const cardRewards = document.getElementById('card-rewards');
                cardRewards.innerHTML = '<h3>é€‰æ‹©ä¸€å¼ å¡ç‰Œ</h3>';
                
                const cardsContainer = document.createElement('div');
                cardsContainer.className = 'cards-container';
                
                rewards.cards.forEach((card, index) => {
                    const cardDiv = document.createElement('div');
                    cardDiv.className = 'card reward-card';
                    if (card.upgraded) {
                        cardDiv.classList.add('upgraded');
                    }
                    cardDiv.innerHTML = `
                        <h5>${card.name} [${card.cost}]</h5>
                        <p>${card.description}</p>
                    `;
                    cardDiv.addEventListener('click', () => {
                        socket.emit('player_action', {
                            action: 'choose_reward',
                            payload: { type: 'card', index }
                        });
                    });
                    cardsContainer.appendChild(cardDiv);
                });
                
                cardRewards.appendChild(cardsContainer);
            }
            
            // æ¸²æŸ“é‡‘å¸å¥–åŠ±
            if (rewards.gold) {
                const goldReward = document.getElementById('gold-reward');
                goldReward.innerHTML = `<h3>è·å¾—é‡‘å¸</h3><p>ğŸ’° ${rewards.gold} é‡‘å¸</p>`;
                goldReward.addEventListener('click', () => {
                    socket.emit('player_action', {
                        action: 'choose_reward',
                        payload: { type: 'gold' }
                    });
                });
            }
            
            // æ¸²æŸ“é—ç‰©å¥–åŠ±
            if (rewards.relic) {
                const relicReward = document.getElementById('relic-reward');
                relicReward.innerHTML = `
                    <h3>è·å¾—é—ç‰©</h3>
                    <div class="relic-item">
                        <h4>${rewards.relic.name}</h4>
                        <p>${rewards.relic.description}</p>
                    </div>
                `;
                relicReward.addEventListener('click', () => {
                    socket.emit('player_action', {
                        action: 'choose_reward',
                        payload: { type: 'relic' }
                    });
                });
            }
            
            // è·³è¿‡å¥–åŠ±æŒ‰é’®
            document.getElementById('skip-rewards-btn').addEventListener('click', () => {
                socket.emit('player_action', {
                    action: 'choose_reward',
                    payload: { type: 'skip' }
                });
            });
        }
        
        function renderShop(state) {
            const template = document.getElementById('shop-screen-template').content.cloneNode(true);
            gameScreen.innerHTML = '';
            gameScreen.appendChild(template);
            
            // å®ç°å•†åº—åŠŸèƒ½
            document.getElementById('leave-shop-btn').addEventListener('click', () => {
                socket.emit('player_action', { action: 'leave_shop' });
            });
        }
        
        function renderRestSite(state) {
            const template = document.getElementById('rest-site-template').content.cloneNode(true);
            gameScreen.innerHTML = '';
            gameScreen.appendChild(template);
            
            // æ·»åŠ ä¼‘æ¯é€‰é¡¹äº‹ä»¶
            document.querySelectorAll('.rest-option').forEach(option => {
                option.addEventListener('click', () => {
                    const choice = option.dataset.option;
                    socket.emit('player_action', {
                        action: 'rest_choice',
                        payload: { choice }
                    });
                });
            });
        }
        
        function renderEvent(state) {
            const template = document.getElementById('event-screen-template').content.cloneNode(true);
            gameScreen.innerHTML = '';
            gameScreen.appendChild(template);
            
            const event = state.currentEvent;
            document.getElementById('event-title').textContent = event.title;
            document.getElementById('event-description').textContent = event.description;
            
            const choicesDiv = document.getElementById('event-choices');
            choicesDiv.innerHTML = '';
            
            event.choices.forEach((choice, index) => {
                const button = document.createElement('button');
                button.textContent = choice;
                button.addEventListener('click', () => {
                    socket.emit('player_action', {
                        action: 'event_choice',
                        payload: { choice_index: index }
                    });
                });
                choicesDiv.appendChild(button);
            });
        }
    </script>
</body>
</html> 